# Execute Product Requirement Prompt (PRP) - Two Truths & A Lie Game

Implement features using intelligent coordination that respects the Two Truths & A Lie Game architecture and provides consistent, high-quality outcomes with Test IO branding.

## PRP File: $ARGUMENTS (from {{ WORKFLOW.ACTIVE_DIR }}/)

## ðŸŽ¯ Intelligent Coordination Approach

**Core Principle**: Default to coordination-aware implementation that respects real-time voting architecture, Socket.io integration, and Test IO brand consistency. Let content and context drive agent selection, not user routing decisions.

### Automatic Workflow Detection

The framework intelligently analyzes your PRP content and context to provide appropriate coordination:

- **Component Pattern Analysis**: Detects which layers are affected (React frontend, Express backend, Socket.io real-time, UI components)
- **Content Scope Analysis**: Understands feature complexity, real-time voting impact, and Test IO brand requirements
- **Context Awareness**: Considers existing game state, active Socket.io connections, and component coordination needs
- **Quality Requirements**: Automatically applies Playwright testing, Test IO brand compliance, and WebSocket validation

### Architecture-Centric Integration by Default

All work assumes and preserves the project's foundational Two Truths & A Lie architecture:
- **Real-time Voting**: Socket.io WebSocket communication patterns for live vote updates
- **Game State Management**: Session-based state with in-memory storage using Map/Object patterns
- **Test IO Brand Compliance**: Professional blue (#1E40AF) and teal (#0891B2) color palette consistency
- **React Component Architecture**: Functional components with hooks, modern JSX patterns
- **WebSocket Event Handling**: Clear event naming conventions (vote-cast, results-update, game-start)
- **Mobile-First Responsive**: TailwindCSS utility-first styling with professional layouts

## ðŸ¤– Intelligent Agent Coordination

Based on content analysis and Two Truths & A Lie architectural requirements, agents are automatically selected:

### Core Coordination Team
- **developer**: Research-first implementation with Socket.io and React architectural awareness
- **tester**: Playwright behavioral testing with WebSocket integration validation and Test IO brand compliance
- **refactor**: Safety-first improvements when component size or Socket.io complexity triggers
- **docs**: User-focused documentation when new voting features or admin APIs are created
- **task-coordinator**: Multi-phase orchestration for complex real-time voting changes

### Smart Agent Selection Logic
```
Content Analysis Results â†’ Agent Selection:

â€¢ React/Socket.io implementation needed â†’ developer (always)
â€¢ Voting UI changes detected â†’ tester (Playwright + visual regression + Test IO brand validation)
â€¢ Components >500 lines â†’ refactor (automatic safety trigger)
â€¢ New admin/voting features â†’ docs (consideration prompt)
â€¢ Real-time architecture changes â†’ task-coordinator (multi-phase orchestration)
â€¢ Socket.io integration work â†’ specialized WebSocket validation
â€¢ Game state coordination â†’ enhanced real-time coordination checks
â€¢ Test IO brand changes â†’ visual validation with brand compliance testing
```

## ðŸ“‹ Standard Execution Workflow

### Phase 1: Analysis & Planning (5-10 min)
1. **Content Analysis**: Automatically detect scope, complexity, and real-time voting integration requirements
2. **Agent Selection**: Choose appropriate agent coordination based on React/Socket.io/Test IO needs
3. **Research Context**: Leverage pre-provided research or initiate MCP research for voting patterns
4. **Architecture Validation**: Ensure Socket.io WebSocket approach and React component integration awareness

### Phase 2: Implementation Coordination (Variable Duration)
1. **Context-Rich Agent Handoffs**: Provide comprehensive context including game state and Socket.io patterns
2. **Quality Gate Monitoring**: Ensure Test IO brand standards and real-time voting standards are maintained
3. **Integration Verification**: Validate changes work within existing React/Express/Socket.io architecture
4. **Progress Tracking**: Monitor implementation progress and coordinate between frontend/backend agents when needed

### Phase 3: Quality Validation & Completion (10-15 min)
1. **Comprehensive Testing**: Playwright behavioral testing with WebSocket integration point validation
2. **Architecture Integration**: Ensure React components and Socket.io events work together properly
3. **Documentation Review**: Verify user-facing voting changes are properly documented
4. **Final Quality Check**: ESLint, TypeScript validation, Test IO brand compliance, and Socket.io architectural compliance

## ðŸ”§ Context-Aware Coordination Features

### Research Context Integration
- **Pre-Research Utilization**: Use research context from PRP generation for voting patterns and Socket.io best practices
- **Targeted MCP Research**: Additional research only when specific real-time voting implementation details are needed
- **Context Preservation**: Maintain research findings about WebSocket patterns throughout implementation coordination

### Architectural Awareness
- **Integration Point Detection**: Automatically identify required React/Express/Socket.io integration work
- **Component Coordination**: Ensure voting components, admin interfaces, and results displays work together seamlessly
- **Game State Management**: Preserve and coordinate voting session state appropriately across WebSocket connections
- **Socket.io Dependencies**: Handle WebSocket connection coordination and graceful degradation scenarios

### Quality Integration
- **Behavioral Testing Focus**: Test voting flows, real-time updates, and admin workflows, not implementation details
- **Integration Testing**: Verify React components and Socket.io events work together correctly
- **Visual Validation**: Playwright screenshot capture for Test IO brand compliance and voting UI changes
- **Documentation Generation**: User-focused documentation for admin setup and voting features

## ðŸš€ Advanced Coordination Scenarios

### Complex Voting Feature Implementation
For multi-component voting features affecting 4+ files or requiring >8 hours of work:
1. **task-coordinator** orchestrates multi-phase real-time voting implementation
2. **Phased approach**: Plan â†’ Implement Frontend â†’ Implement Backend â†’ Socket.io Integration â†’ Validate
3. **Quality gates**: Checkpoints at each phase with user approval and Playwright testing
4. **Context preservation**: Maintain game state and WebSocket architectural context across phases

### Real-time Architecture Modifications
For changes affecting core Socket.io architecture or voting integration patterns:
1. **Architecture-first analysis**: Understand WebSocket impact on existing game state before implementation
2. **Incremental approach**: Small, safe changes with Socket.io validation at each step
3. **Integration testing**: Comprehensive Playwright testing of voting integration points
4. **Rollback planning**: Clear rollback strategy if WebSocket integration issues arise

### Test IO Brand Integration Work
For Test IO brand compliance or visual integration coordination:
1. **Brand pattern analysis**: Use established Test IO visual integration patterns from brand reference
2. **Fallback strategy**: Implement brand fallback and graceful visual degradation
3. **Context sharing**: Ensure Test IO brand context is preserved across components
4. **Visual testing**: Playwright-based testing for brand compliance and visual regression

## ðŸ“Š Success Criteria

### Functional Success
- All specified voting features work as defined in the PRP
- Socket.io WebSocket integration points function correctly with existing real-time architecture
- Error scenarios are handled gracefully with appropriate user feedback and WebSocket reconnection
- Performance meets established voting system standards with real-time responsiveness

### Architectural Success
- Changes integrate seamlessly with existing React component and Socket.io coordination patterns
- WebSocket integration follows established voting patterns and includes proper connection fallback
- Game state management maintains consistency with existing session-based architecture
- Test IO brand compliance is consistent throughout all UI components

### Quality Success
- All Playwright tests pass including new behavioral tests for voting workflows
- Code quality tools (ESLint, TypeScript) pass without warnings
- File size limits are respected (500 lines for components, 1000 for tests)
- Documentation is created for user-facing admin and voting features
- Test IO brand visual compliance verified through Playwright screenshot testing

## ðŸŽ¯ Completion

Implementation is complete when:
1. All PRP voting requirements are functionally implemented with real-time updates
2. React/Express/Socket.io architecture integration is verified working
3. Quality gates pass (Playwright tests, linting, Test IO brand compliance)
4. User acceptance criteria from PRP are met for both admin and voting workflows
5. No regressions in existing voting functionality or WebSocket connections

**Implementation Philosophy**: Leverage intelligent coordination to deliver high-quality real-time voting features that integrate seamlessly with existing React/Socket.io architecture while maintaining Test IO brand standards and professional voting experience patterns.